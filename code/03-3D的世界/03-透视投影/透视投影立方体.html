<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
    <style>
      * {
        margin: 0;
        padding: 0;
      }
      canvas {
        width: 100vw;
        height: 100vh;
        display: block;
      }
    </style>
  </head>
  <body>
    <canvas></canvas>

    <script>
      // 获取canvas元素
      let canvas = document.querySelector("canvas");
      //   设置canvas的宽高
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      // 获取webgl上下文
      let gl = canvas.getContext("webgl");
      //   开启深度测试
      gl.enable(gl.DEPTH_TEST);

      // 创建顶点着色器
      const vShader = gl.createShader(gl.VERTEX_SHADER);

      // 顶点着色器源码
      gl.shaderSource(
        vShader,
        /*glsl*/ `
          attribute vec4 v_color;
          attribute vec4 v_position;
          varying vec4 vColor;
          uniform mat4 rotationMatrix;

          //获取uniform传递的相机位置
          uniform vec3 cameraPosition;
          //获取uniform传递的相机朝向
          uniform vec3 cameraDirection;
          //获取uniform传递的相机上方向
          uniform vec3 cameraUp;
          //获取uniform相机宽高比例
          uniform float aspect;
          //获取uniform传递的相机近平面距离
          uniform float near;
          //获取uniform传递的相机远平面距离
          uniform float far;
          //获取uniform传递的相机高度
          uniform float height;

        //   获取相机透视投影的矩阵
        uniform mat4 projectionMatrix;
          void main(){
            // 移动相机到原点的基向量变换矩阵
            mat4 tMatrix = mat4(
              1.0,0.0,0.0,0.0,
              0.0,1.0,0.0,0.0,
              0.0,0.0,1.0,0.0,
              -cameraPosition.x,-cameraPosition.y,-cameraPosition.z,1.0
            );

            // 旋转相机的基变换矩阵
            vec3 zAxis = normalize(cameraDirection);
            vec3 yAxis = normalize(cameraUp);
            vec3 xAxis = cross(yAxis,zAxis);

            // 旋转相机的逆变换
            mat4 rMatrix = mat4(
              xAxis.x,yAxis.x,zAxis.x,0.0,
              xAxis.y,yAxis.y,zAxis.y,0.0,
              xAxis.z,yAxis.z,zAxis.z,0.0,
              0.0,0.0,0.0,1.0
            );

            // 正交投影移动
            mat4 oTranslateMatrix = mat4(
              1.0,0.0,0.0,0.0,
              0.0,1.0,0.0,0.0,
              0.0,0.0,1.0,0.0,
              0.0,0.0,-(near+far)/2.0,1.0
            );
            // 正交投影的缩放
            mat4 oScaleMatrix = mat4(
              1.0/(aspect*height),0.0,0.0,0.0,
              0.0,1.0/height,0.0,0.0,
              0.0,0.0,2.0/(far-near),0.0,
              0.0,0.0,0.0,1.0
            );
            gl_Position =  projectionMatrix*rMatrix*tMatrix*rotationMatrix * v_position;
            vColor = v_color;
          }
        `
      );
      //   编译顶点着色器
      gl.compileShader(vShader);

      // 创建片元着色器
      const fShader = gl.createShader(gl.FRAGMENT_SHADER);
      // 片元着色器源码
      gl.shaderSource(
        fShader,
        /*glsl*/ `
          precision mediump float;
          varying vec4 vColor;
          void main(){
              gl_FragColor = vColor;
          }
          `
      );

      // 编译片元着色器
      gl.compileShader(fShader);

      // 创建着色器程序链接顶点着色器和片元着色器
      const program = gl.createProgram();
      //   添加顶点着色器
      gl.attachShader(program, vShader);
      //   添加片元着色器
      gl.attachShader(program, fShader);
      //   链接着色器程序
      gl.linkProgram(program);
      //   使用着色器程序
      gl.useProgram(program);

      //   创建顶点颜色数据
      const color = gl.getAttribLocation(program, "v_color");
      //   创建颜色缓存区
      const cBuffer = gl.createBuffer();
      //   绑定颜色缓存区
      gl.bindBuffer(gl.ARRAY_BUFFER, cBuffer);
      //   向颜色缓存区提供attribute数据
      gl.vertexAttribPointer(color, 4, gl.FLOAT, false, 0, 0);
      //   开启颜色缓存区
      gl.enableVertexAttribArray(color);

      // 创建顶点数据
      const position = gl.getAttribLocation(program, "v_position");
      //   创建缓冲区
      const pBuffer = gl.createBuffer();
      //   绑定缓冲区
      gl.bindBuffer(gl.ARRAY_BUFFER, pBuffer);

      // 将顶点数据提供给到atttribute变量
      gl.vertexAttribPointer(
        //告诉attribute变量从哪里获取数据
        position,
        4, // 每次迭代提供4个单位的数据
        gl.FLOAT, // 每个单位的数据类型是32位浮点型
        false, // 不需要归一化数据
        0, // 0 步长
        0 // 从缓冲区的哪个位置开始读取数据
      );

      //   开启attribute变量
      gl.enableVertexAttribArray(position);

      //   设置8个顶点的坐标
      let vertices = [
        [-0.5, -0.5, 0.5, 1.0],
        [-0.5, 0.5, 0.5, 1.0],
        [0.5, 0.5, 0.5, 1.0],
        [0.5, -0.5, 0.5, 1.0],
        [-0.5, -0.5, -0.5, 1.0],
        [-0.5, 0.5, -0.5, 1.0],
        [0.5, 0.5, -0.5, 1.0],
        [0.5, -0.5, -0.5, 1.0],
      ];

      //   根据顶点设置6个面
      let faces = [
        [1, 0, 3, 2],
        [2, 3, 7, 6],
        [3, 0, 4, 7],
        [6, 5, 1, 2],
        [4, 5, 6, 7],
        [5, 4, 0, 1],
      ];

      //   设置6个面的颜色

      let faceColors = [
        [1.0, 0.0, 0.0, 1.0], // red
        [0.0, 1.0, 0.0, 1.0], // green
        [0.0, 0.0, 1.0, 1.0], // blue
        [1.0, 1.0, 0.0, 1.0], // yellow
        [1.0, 0.0, 1.0, 1.0], // purple
        [0.0, 1.0, 1.0, 1.0], // cyan
      ];

      let points = [];
      let colors = [];

      faces.forEach((face, i) => {
        let faceIndices = [
          face[0],
          face[1],
          face[2],
          face[0],
          face[2],
          face[3],
        ];

        faceIndices.forEach((index) => {
          points.push(vertices[index]);
          colors.push(faceColors[i]);
        });
      });

      //   绑定顶点的缓冲区
      gl.bindBuffer(gl.ARRAY_BUFFER, pBuffer);

      //   设置顶点数据
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array(points.flat()),
        gl.STATIC_DRAW // 静态绘制
      );

      //   绑定颜色缓冲区
      gl.bindBuffer(gl.ARRAY_BUFFER, cBuffer);
      //  设置颜色数据
      gl.bufferData(
        gl.ARRAY_BUFFER,
        new Float32Array(colors.flat()),
        gl.STATIC_DRAW
      );
      //   初始化旋转角度
      let angle = 0;
      let rotationMatrix = gl.getUniformLocation(program, "rotationMatrix");
      let mat = [
        [Math.cos(angle), 0, Math.sin(angle), 0],
        [0, 1, 0, 0],
        [-Math.sin(angle), 0, Math.cos(angle), 0],
        [0, 0, 0, 1],
      ];
      gl.uniformMatrix4fv(rotationMatrix, false, new Float32Array(mat.flat()));

      // 设置相机位置
      let camera = [2, 2, 2];
      let cameraDirection = [-1, -1, -1];
      let cameraUp = [-1, 2, -1];
      // 相机宽高比例
      let aspect = canvas.width / canvas.height;
      let near = 0.1;
      let far = 100;
      let height = 3;

      //   相机垂直视野角度
      let fov = 70;
      //   相机透视投影矩阵
      let pMatrix = [
        [1 / (aspect * Math.tan((fov * Math.PI) / 360)), 0, 0, 0],
        [0, 1 / Math.tan((fov * Math.PI) / 360), 0, 0],
        [0, 0, (far + near) / (far - near), 1],
        [0, 0, (-2 * far * near) / (far - near), 0],
      ];
      let projectionMatrix = gl.getUniformLocation(program, "projectionMatrix");
      gl.uniformMatrix4fv(
        projectionMatrix,
        false,
        new Float32Array(pMatrix.flat())
      );

      // 将相机位置传给着色器
      let cameraPosition = gl.getUniformLocation(program, "cameraPosition");
      gl.uniform3fv(cameraPosition, camera);
      // 将相机方向传给着色器
      let cameraDirectionPosition = gl.getUniformLocation(
        program,
        "cameraDirection"
      );
      gl.uniform3fv(cameraDirectionPosition, cameraDirection);
      // 将相机上方向传给着色器
      let cameraUpPosition = gl.getUniformLocation(program, "cameraUp");
      gl.uniform3fv(cameraUpPosition, cameraUp);
      // 将相机宽高比例传给着色器
      let aspectPosition = gl.getUniformLocation(program, "aspect");
      gl.uniform1f(aspectPosition, aspect);
      // 将相机近平面传给着色器
      let nearPosition = gl.getUniformLocation(program, "near");
      gl.uniform1f(nearPosition, near);
      // 将相机远平面传给着色器
      let farPosition = gl.getUniformLocation(program, "far");
      gl.uniform1f(farPosition, far);
      // 将相机高度传给着色器
      let heightPosition = gl.getUniformLocation(program, "height");
      gl.uniform1f(heightPosition, height);

      function render() {
        angle += 0.01;
        let mat = [
          [Math.cos(angle), 0, Math.sin(angle), 0],
          [0, 1, 0, 0],
          [-Math.sin(angle), 0, Math.cos(angle), 0],
          [0, 0, 0, 1],
        ];
        gl.uniformMatrix4fv(
          rotationMatrix,
          false,
          new Float32Array(mat.flat())
        );
        //   绘制
        gl.drawArrays(gl.TRIANGLES, 0, points.length);
        requestAnimationFrame(render);
      }

      render();
    </script>
  </body>
</html>
